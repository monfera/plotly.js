module.exports = "\n     precision lowp float;\n\n     attribute vec4 p0, p1, p2, p3,\n                    p4, p5, p6, p7,\n                    p8, p9, pa, pb,\n                    color;\n\n     attribute float x,\n                     depth;\n\n     uniform mat4 var1A, var2A, var1B, var2B, var1C, var2C,\n                  loA, hiA, loB, hiB, loC, hiC;\n\n     uniform vec2 resolution,\n                  viewBoxPosition,\n                  viewBoxSize;\n\n     varying vec4 fragColor;\n\n     vec4 zero = vec4(0, 0, 0, 0);\n     vec4 unit = vec4(1, 1, 1, 1);\n     vec2 xyProjection = vec2(1, -1);\n\n     mat4 mclamp(mat4 m, mat4 lo, mat4 hi) {\n       return mat4(clamp(m[0], lo[0], hi[0]),\n                   clamp(m[1], lo[1], hi[1]),\n                   clamp(m[2], lo[2], hi[2]),\n                   clamp(m[3], lo[3], hi[3]));\n     }\n\n     bool mshow(mat4 p, mat4 lo, mat4 hi) {\n       return mclamp(p, lo, hi) == p;\n     }\n\n     float val(mat4 p, mat4 v) {\n       return dot(matrixCompMult(p, v) * unit, unit);\n     }\n\n     void main() {\n\n       mat4 pA = mat4(p0, p1, p2, p3);\n       mat4 pB = mat4(p4, p5, p6, p7);\n       mat4 pC = mat4(p8, p9, pa, pb);\n\n       float show = float(mshow(pA, loA, hiA) &&\n                          mshow(pB, loB, hiB) &&\n                          mshow(pC, loC, hiC));\n\n       vec2 yy = show * vec2(val(pA, var1A) + val(pB, var1B) + val(pC, var1C),\n                             val(pA, var2A) + val(pB, var2B) + val(pC, var2C));\n\n       float y = dot(yy, vec2(1.0 - x, x));\n\n       vec2 viewBoxXY = viewBoxPosition + viewBoxSize * vec2(x, y);\n\n       float depthOrHide = depth + 2.0 * (1.0 - show);\n\n       gl_Position = vec4(\n         xyProjection * (2.0 * viewBoxXY / resolution - 1.0),\n         depthOrHide,\n         1.0\n       );\n\n       fragColor = color;\n     }\n\n  ";